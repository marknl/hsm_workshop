---------------------
## Salting
Also when signing/encrypting some random is sometimes needed! This
is commonly called a 'salt' or an 'initialization vector'.\
This random could be generated by an HSM, but is never stored in the
HSM, it is the responsibility of the signing or encrypting software.

Why salt? The more you use a key, the more output of your key is
available to the crackers, the higher the risk becomes of them finding
the key.

This is known as an "offline, stored dictionary attack", just
pre-calculate (and store and index) all possible options...

With different salting, even identical input and an identical key will
give you different output every time. And this salt doesn't even need to be a secret\
So put a little random into a signature/encryption, this will make a
stored dictionary attack much more difficult, even pseudo random will
do.\
E.g. NSEC3 can be salted. But the latest RFC advices against it:
> "In the case of DNS, the situation is different because the hashed
> names placed in NSEC3 records are always implicitly 'salted' by
> hashing the FQDN from each zone."
[source](https://datatracker.ietf.org/doc/html/rfc9276#name-salt)

[Next](https://github.com/niek-sidn/hsm_workshop/blob/main/Slide08.md)

## Exercise \"Finland is salty\"
-   Issue this command (or your OS\'s equivalent): kdig +dnssec +multi
    nsec3param fi. \@1.1.1.1
-   now do .nl
-   now do .se ( Hint: if the penny doesn\'t drop, do
    blah-nonexistant.se. (no nsec3 in .se, so no salt))

------------------------
[Next](https://github.com/niek-sidn/hsm_workshop/blob/main/Slide08.md)
